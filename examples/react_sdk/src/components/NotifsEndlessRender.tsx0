import React, { useState, useEffect } from 'react';
import { TinadSDK, SDKNotification } from '@thisisnotadrill/react-core';

interface NotificationsComponentProps {
  displayMode: 'sequential' | 'single';
  autoDismissTime?: number; // milliseconds
  pageId?: string;
}

const NotificationsComponent: React.FC<NotificationsComponentProps> = ({
    displayMode,
    autoDismissTime = 0,
    pageId,
}) => {
    const { data: sdkNotifications, isLoading, isError, error } = TinadSDK.useSDKData(pageId);
    const [notificationsQueue, setNotificationsQueue] = useState<SDKNotification[]>([]);
    const [displayIndex, setDisplayIndex] = useState(0);

    // Process new notifications and update queue only when not loading and on data change
    useEffect(() => {
        if (!isLoading && sdkNotifications && sdkNotifications.length > 0) {
            setNotificationsQueue(currentQueue => [...currentQueue, ...sdkNotifications]);
        }
    }, [sdkNotifications, isLoading]);

    // Auto-dismiss or manual dismiss based on provided props
    useEffect(() => {
        let timer: NodeJS.Timeout;
        if (displayMode === 'sequential' && notificationsQueue.length > 0 && autoDismissTime && displayIndex < notificationsQueue.length) {
            timer = setTimeout(() => {
                setDisplayIndex(currentIndex => (currentIndex + 1) % notificationsQueue.length);
            }, autoDismissTime);
        }

        return () => clearTimeout(timer);
    }, [displayIndex, notificationsQueue, displayMode, autoDismissTime]);

    const dismissNotification = () => {
        if (displayMode === 'sequential') {
            if (displayIndex + 1 === notificationsQueue.length) {
                setNotificationsQueue([]);
                setDisplayIndex(0);
            } else {
                setDisplayIndex(currentIndex => currentIndex + 1);
            }
        } else {
            // Reset queue if not in sequential mode, effectively dismissing the single shown notification
            setNotificationsQueue([]);
            setDisplayIndex(0);
        }
    };

    // Handle empty or error states
    if (isLoading) return <div>Loading...</div>;
    if (isError || notificationsQueue.length === 0) return <div>Error: {error?.message || "No notifications"}</div>;

    // Display current notification based on displayIndex
    const currentNotification = notificationsQueue[displayIndex % notificationsQueue.length];

    return (
        <div>
            {currentNotification && (
                <div>
                    <p>Message: {currentNotification.content}</p>
                    <p>Type: {currentNotification.notificationType}</p>
                    <button onClick={dismissNotification}>Dismiss</button>
                    </div>
            )}
        </div>
    );
};

export default NotificationsComponent;
